# Disruptor

## 先验知识

### 1. Padding

内存填充（padding）是一种在计算机系统中用于优化内存访问和缓存性能的技术。填充的目的是使数据结构的内存布局对齐到特定的边界，从而减少内存对齐和伪共享带来的性能损失。

填充技术通过增加无意义的额外成员变量，使得数据结构的大小能够整除缓存行大小或者对齐边界。这样一来，当访问数据结构中的一个成员时，只会导致所在的缓存行被加载到缓存中，而不会加载相邻的缓存行，从而减少了不必要的内存访问和缓存刷新的开销。

填充的使用可以提升系统的性能，尤其是在多线程环境下。其中最常见的应用是解决伪共享（false sharing）问题。伪共享指的是多个线程同时访问相邻内存位置，导致缓存行在不同线程之间频繁地切换，从而降低性能。通过填充数据结构，使其占用整个缓存行，可以避免不必要的缓存行刷新，减少伪共享的影响。

当一个线程修改缓存行中的某个变量时，该缓存行会被标记为"脏"（dirty），即需要将其写回主内存。如果另一个线程正在同时访问相同的缓存行中的其他变量，那么该缓存行会被从主内存中加载到其缓存中，这会导致额外的内存访问开销和缓存行的刷新，从而降低性能。

伪共享问题对性能的影响主要体现在以下几个方面：

* **缓存行刷新**：当多个线程同时修改共享缓存行中的不同变量时，需要频繁地进行缓存行的刷新，导致额外的内存访问开销。

* **竞争和同步**：伪共享问题会引发线程之间的竞争和同步，因为它们需要获取和释放缓存行的锁定。这会导致线程间的等待和调度开销。

* **性能下降**：由于缓存行刷新和线程竞争的开销，伪共享问题会导致程序的整体性能下降，尤其是在高并发和频繁访问共享数据的情况下。

### 2. Fake Sharing

伪共享（false sharing）是一种在多线程编程中出现的性能问题，它与缓存和内存的访问模式有关。伪共享问题通常发生在多个线程同时访问不同的变量，而这些变量共享同一个缓存行（cache line）的情况下。

缓存是位于CPU核心和主内存之间的高速存储器，用于加速数据的读取和写入。缓存以缓存行为单位进行读取和写入操作，而缓存行的大小通常为64字节（在大多数现代处理器中）。当多个线程同时访问位于同一个缓存行的不同变量时，就可能发生伪共享。

## 特性

### 1. Sequence 内存填充

为了防止伪共享，Sequence 对象在内部使用内存填充（padding）来保证多线程对 `sequence_` 的并发读写不会出现 Fake Sharing 的问题。填充通过增加一些额外的无意义成员变量实现，使得每个 Sequence 对象占用的内存大小与 CPU 缓存行相匹配，从而减少不必要的缓存行刷新。

```c++
class Sequence {
 ...

 private:
  // 内存填充
  int64_t padding0_[ATOMIC_SEQUENCE_PADDING_LENGTH];
  // 序列号
  std::atomic<int64_t> sequence_;
  // 内存填充
  int64_t padding1_[ATOMIC_SEQUENCE_PADDING_LENGTH];

  ...
};
```
